#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
# generated by wxGlade 0.6.8 on Sun Jan 31 14:02:25 2016
#

############################################################
### TBD:
### Read from file in thread
### Make publisher to GUI
### Update GUI in gui thread, but do all communication in seperate thread
### See example in kodi links ....

try:
    import wx
except ImportError:
    print "wxpython not installed, wxpython is required to use this GUI"
    print "Install wxpython"
    print "See: http://www.wxpython.org/download.php"
    exit()

# begin wxGlade: dependencies
import gettext
# end wxGlade

# begin wxGlade: extracode
# end wxGlade

#imports
import os, subprocess
import json
from xml.dom import minidom
import time
from itertools import chain
import socket
import getpass
import sys
import re
import threading
import wx.lib.pubsub

if sys.version_info.major == 3:
    from urllib.request import HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, Request, build_opener
    from urllib.parse import urlencode
else:
    from urllib2 import HTTPPasswordMgrWithDefaultRealm, HTTPBasicAuthHandler, Request, build_opener
    from urllib import urlencode
    
JSONGETPATH = '{"jsonrpc": "2.0", "method": "Addons.GetAddonDetails", "params": { "addonid": "service.webgrabplusplus","properties": ["path"]}, "id": 1 }'
JSONEXECADDON = '{"jsonrpc": "2.0", "method": "Addons.ExecuteAddon", "params": { "wait": false, "addonid": "service.webgrabplusplus","params": %s}, "id": 1 }'

#globals
settings = []
url = ""

#status
STAT_UNKNOWN  = 0
STAT_GRABBING = 1
STAT_POSTPROC = 2
STAT_IDLE     = 3
STAT_ERROR    = 4

SOCKET_TIMEOUT = 5000 #ms
COMM_RETRIES = 5

UPDATE_TIME = 5000 #milliseconds

#########################################################
# Functions                                             #
#########################################################
### 

millis = lambda: int(round(time.time() * 1000))

def curl(url, params=None, auth=None, req_type="GET", data=None, headers=None):
    post_req = ["POST", "PUT"]
    get_req = ["GET", "DELETE"]

    if params is not None:
        url += "?" + urlencode(params)

    if req_type not in post_req + get_req:
        raise IOError("Wrong request type \"%s\" passed" % req_type)

    _headers = {}
    handler_chain = []

    if auth is not None:
        manager = HTTPPasswordMgrWithDefaultRealm()
        manager.add_password(None, url, auth["user"], auth["pass"])
        handler_chain.append(HTTPBasicAuthHandler(manager))

    if req_type in post_req and data is not None:
        _headers["Content-Length"] = len(data)

    if headers is not None:
        _headers.update(headers)

    director = build_opener(*handler_chain)

    if req_type in post_req:
        if sys.version_info.major == 3:
            _data = bytes(data, encoding='utf8')
        else:
            _data = bytes(data)

        req = Request(url, headers=_headers, data=_data)
    else:
        req = Request(url, headers=_headers)

    req.get_method = lambda: req_type
    result = director.open(req)

    return result.read()

def JsonRPC(url, udata):
    return curl(url, req_type="POST", data=udata, headers={"Content-Type":"application/json"})
    
def getProcessPID(process):
    _syscmd = subprocess.Popen(['pidof', process], stdout=subprocess.PIPE)
    PID = _syscmd.stdout.read().strip()
    return PID if PID > 0 else False

def GetSetting(search):
    for a in settings:
        if (a[0].lower() == search.lower()):
            return a[1]

    return None   
 
def GetSettingsFromKodi(path):
    if not os.path.isfile(path):
        print "Settingsfile does not exist: %s" % (path)
        dlg = wx.MessageDialog(None, 
                "Settingsfile does not exist: %s" % (path),
                "Settings error", wx.OK|wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        exit()
    
    global settings
    settings = []
    try:
        __xml = minidom.parse(path)
        nodes = __xml.getElementsByTagName("settings")
        if nodes:
            for node in nodes:
                asettings=node.getElementsByTagName('setting')
                for a in asettings:
                    settings.append([a.getAttribute("id"),a.getAttribute("value")])
    except Exception, e:
        print "Error reading from settingsfile: %s" % (path)
        dlg = wx.MessageDialog(None, 
                "Settingsfile does not exist: %s" % (path),
                "Settings error", wx.OK|wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        exit()
    return
    
def GetPortFromKodi(path):
    port = ""
    if not os.path.isfile(path):
        print "Settingsfile does not exist: %s" % (path)
        dlg = wx.MessageDialog(None, 
                "Settingsfile does not exist: %s" % (path),
                "Settings error", wx.OK|wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        exit()
    
    try:
        __xml = minidom.parse(path)
        nodes = __xml.getElementsByTagName("settings")
        if nodes:
            for node in nodes:
                anodes=node.getElementsByTagName('services')
                for a in anodes:
                    aid=node.getElementsByTagName('webserverport')
                    for b in aid:
                        port=b.childNodes[0].data
    except Exception, e:
        print "Error reading from settingsfile: %s" % (path)
        dlg = wx.MessageDialog(None, 
                "Error reading from settingsfile: %s" % (path),
                "Settings error", wx.OK|wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        exit()
    return port
    
def GetUserDataFolder():
    pf = sys.platform.lower()
    usr = getpass.getuser()
    udf = ""
    if pf == 'linux' or pf == 'linux2':
        udf = '/home/%s/.kodi/userdata/'%usr
    elif pf == 'windows':
        udf = 'C:\Users\%s\AppData\Roaming\Kodi\userdata\\'%usr
    elif pf == 'android':
        udf = '/sdcard/Android/data/org.xbmc.kodi/files/.kodi/userdata/'
    elif pf == 'ios':
        udf = '/private/var/mobile/Library/Preferences/Kodi/userdata/'
    elif pf == 'darwin':
        udf = '/Users/%s/Library/Application Support/Kodi/userdata/'%usr
    return udf

def OpenSocket():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    s.bind(('localhost', int(GetSetting("socket_port"))))
    s.listen(5) # become a server socket, maximum 5 connections
    s.settimeout(SOCKET_TIMEOUT/1000)
    
    return s

def Communicate(s,url,cmd):
    tries = 0
    rec = ""
    while (rec == "") and (tries < COMM_RETRIES):
        tries += 1
        try:
            res=json.loads(JsonRPC(url,JSONEXECADDON%cmd))['result']
            if (res == "OK"):
                rec=SocketReceive(s)
        except:
            print "Communication Error"
    return rec

def SocketReceive(s):
    buf = ""
    
    try:
        connection, address = s.accept()
        buf = connection.recv(64)
    except socket.timeout:
        print "Timeout"
    return buf
 
def CloseSocket(s):
    s.close()   

def GetStatus(s):
    Arguments = "\"-s\""   
    rec = Communicate(s, url, Arguments)
    if (rec == ""):
        print "Communication Error: Getstatus returned None"
        dlg = wx.MessageDialog(None, 
                "Communication Error: Getstatus returned None",
                "Communication Error", wx.OK|wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        exit()
    return int(rec)
    
def SetStartGrabbing(s):
    Arguments = "\"-g\""   
    rec = Communicate(s, url, Arguments)
    if (rec == ""):
        print "Communication Error: SetStartGrabbing returned None"
        dlg = wx.MessageDialog(None, 
                "Communication Error: SetStartGrabbing returned None",
                "Communication Error", wx.OK|wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        exit()
    return rec

#########################################################
# Params in message                                     #
#########################################################
###

_STATUS = 0
_NEXTGRAB = 1
_CHANNEL = 2
_CHANNELCOUNTER = 3
_CHANNELS = 4
_FINISHTIME = 5
_DURATION = 6
_SHOWS = 7
_TOTALCHANNELS = 8
_NEW = 9
_UPDATED = 10
    
def EncodeParams(Status,NextGrab, FinishTime, LogInfo, OldInfo):
    strlist = [str(Status), NextGrab, LogInfo.Channel, str(LogInfo.ChannelCounter), str(LogInfo.Channels), FinishTime, str(OldInfo.Duration), str(OldInfo.Shows), str(OldInfo.TotalChannels), str(OldInfo.New), str(OldInfo.Updated)]
    return "#".join(strlist)

def DecodeParams(Enc):
    return Enc.split("#")

#########################################################
# Timer Thread                                          #
#########################################################
### 

class TimerThread(threading.Thread):
 
    #----------------------------------------------------------------------
    def __init__(self):
        self._stopevent = threading.Event()
        self._grabevent = threading.Event()
        self.Status = STAT_UNKNOWN
        self.OldStatus = STAT_UNKNOWN
        self.NextGrab = "N/A"
        try:
            epg_interval = int(re.match('\d+', GetSetting('epg_interval')).group())
        except:
            epg_interval = 0
        self.LogInfo = progress.LogFile(epg_interval,GetSetting('wg_logfile'))
        self.WGInfoOld = progress.WGInfo()
        self.socket = OpenSocket()
        threading.Thread.__init__(self)
        self.start()    # start the thread
 
    #----------------------------------------------------------------------
    def run(self):
        FirstRunDone=False
        prev_time = millis()
        while not self._stopevent.isSet():
            if (millis()-prev_time >= UPDATE_TIME):
                self.CheckService(FirstRunDone)
                FirstRunDone=True
                prev_time = millis()
            else:
                if self._grabevent.isSet():
                    self._stopevent.clear()
                    SetStartGrabbing(self.socket)
                time.sleep(0.5)
 
    #----------------------------------------------------------------------
    def join(self, timeout=None):
        self._stopevent.set()
        threading.Thread.join(self, timeout)
        CloseSocket(self.socket)
        
    #----------------------------------------------------------------------
    def startgrab(self):
        self._grabevent.set()
        
    def GetNextGrab(self):
        if self.Status == STAT_GRABBING:
            self.NextGrab = self.LogInfo.Epoch2Date(0)
        else:
            self.NextGrab = self.LogInfo.Epoch2Date(self.LogInfo.CalcNextUpdate())
    
    def CheckService(self, Timed):
        #print "Checking service"
        self.Status = GetStatus(self.socket)
    
        if not Timed:
            # First run, get everything and read logfile...
            self.LogInfo.ReadLogFile()
            self.WGInfoOld = self.LogInfo.CopyLog(self.WGInfoOld)
            self.LogInfo.ReadLogFile(True)
            self.GetNextGrab()
            wx.CallAfter(self.postUpdate)
            self.OldStatus = self.Status
        else:
            # Check timed      
            if (self.Status != self.OldStatus):
                # Status changed, if grabbing, only read current logfile and keep old
                if (self.Status == STAT_GRABBING):
                    self.LogInfo.ReadLogFile(True)
                    self.GetNextGrab()
                    wx.CallAfter(self.postUpdate)
                # if idle, read log and copy once
                elif (self.Status == STAT_IDLE):
                    self.LogInfo.ReadLogFile()
                    self.WGInfoOld = self.LogInfo.CopyLog(self.WGInfoOld)
                    self.GetNextGrab()
                    wx.CallAfter(self.postUpdate)
            elif (self.Status == STAT_GRABBING):
                # Read current logfile
                self.LogInfo.ReadLogFile(True)
                self.GetNextGrab()
                wx.CallAfter(self.postUpdate)
            self.OldStatus = self.Status
        return True
    
    def postUpdate(self):
        wx.lib.pubsub.Publisher().sendMessage("update", EncodeParams(self.Status, self.NextGrab, self.LogInfo.Epoch2Dates(self.WGInfoOld.FinishedTime), self.LogInfo.WGInfo, self.WGInfoOld)) 
        
#########################################################
# WX Class                                              #
#########################################################
###    

class MyFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: MyFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        self.label_1 = wx.StaticText(self, wx.ID_ANY, _("Scheduler status:"), style=wx.ALIGN_RIGHT)
        self.text_ctrl_status = wx.TextCtrl(self, wx.ID_ANY, _("Unknown"), style=wx.TE_READONLY)
        self.static_line_2 = wx.StaticLine(self, wx.ID_ANY)
        self.label_4 = wx.StaticText(self, wx.ID_ANY, _("Next scheduled grab:"), style=wx.ALIGN_RIGHT)
        self.text_ctrl_next = wx.TextCtrl(self, wx.ID_ANY, _("N/A"), style=wx.TE_READONLY)
        self.label_2 = wx.StaticText(self, wx.ID_ANY, _("Current channel grabbing:"), style=wx.ALIGN_RIGHT)
        self.text_ctrl_channel = wx.TextCtrl(self, wx.ID_ANY, _("-"), style=wx.TE_READONLY)
        self.label_3 = wx.StaticText(self, wx.ID_ANY, _("Grab progress:"), style=wx.ALIGN_RIGHT)
        self.text_ctrl_progress = wx.TextCtrl(self, wx.ID_ANY, _("0/ 0"), style=wx.TE_READONLY)
        self.gauge_progress = wx.Gauge(self, wx.ID_ANY, 100)
        self.static_line_1 = wx.StaticLine(self, wx.ID_ANY, style=wx.LI_VERTICAL)
        self.label_5 = wx.StaticText(self, wx.ID_ANY, _("Latest grab finished:"), style=wx.ALIGN_RIGHT)
        self.text_ctrl_latest = wx.TextCtrl(self, wx.ID_ANY, _("N/A"), style=wx.TE_READONLY)
        self.text_ctrl_seconds = wx.TextCtrl(self, wx.ID_ANY, _("0"), style=wx.TE_READONLY | wx.TE_RIGHT)
        self.label_6 = wx.StaticText(self, wx.ID_ANY, _("seconds of grabbing"))
        self.text_ctrl_shows = wx.TextCtrl(self, wx.ID_ANY, _("0"), style=wx.TE_READONLY | wx.TE_RIGHT)
        self.label_7 = wx.StaticText(self, wx.ID_ANY, _("shows in databse"))
        self.text_ctrl_channels = wx.TextCtrl(self, wx.ID_ANY, _("0"), style=wx.TE_READONLY | wx.TE_RIGHT)
        self.label_8 = wx.StaticText(self, wx.ID_ANY, _("channels"))
        self.text_ctrl_new = wx.TextCtrl(self, wx.ID_ANY, _("0"), style=wx.TE_READONLY | wx.TE_RIGHT)
        self.label_9 = wx.StaticText(self, wx.ID_ANY, _("new shows added"))
        self.text_ctrl_updated = wx.TextCtrl(self, wx.ID_ANY, _("0"), style=wx.TE_READONLY | wx.TE_RIGHT)
        self.label_10 = wx.StaticText(self, wx.ID_ANY, _("shows updated"))
        self.static_line_3 = wx.StaticLine(self, wx.ID_ANY)
        self.button_force = wx.Button(self, wx.ID_ANY, _("Force Start"))

        self.__set_properties()
        self.__do_layout()
        # end wxGlade
        
        self.Bind(wx.EVT_BUTTON, self.OnForce, self.button_force)
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        self.button_force.Disable()
        
        # create a pubsub receiver
        wx.lib.pubsub.Publisher().subscribe(self.updateDisplay, "update")
        self.Timer = TimerThread()

    def __set_properties(self):
        # begin wxGlade: MyFrame.__set_properties
        self.SetTitle(_("WebGrabGui - Gui for KODI WebGrab++ Manager"))
        self.SetSize((689, 239))
        self.label_1.SetMinSize((165, 15))
        self.text_ctrl_status.SetMinSize((335, 27))
        self.label_4.SetMinSize((165, 15))
        self.text_ctrl_next.SetMinSize((165, 27))
        self.label_2.SetMinSize((165, 15))
        self.text_ctrl_channel.SetMinSize((165, 27))
        self.label_3.SetMinSize((165, 15))
        self.text_ctrl_progress.SetMinSize((165, 27))
        self.gauge_progress.SetMinSize((330, 28))
        self.label_5.SetMinSize((165, 15))
        self.text_ctrl_latest.SetMinSize((165, 27))
        self.text_ctrl_seconds.SetMinSize((165, 27))
        self.label_6.SetMinSize((165, 15))
        self.text_ctrl_shows.SetMinSize((165, 27))
        self.label_7.SetMinSize((165, 15))
        self.text_ctrl_channels.SetMinSize((165, 27))
        self.label_8.SetMinSize((165, 15))
        self.text_ctrl_new.SetMinSize((165, 27))
        self.label_9.SetMinSize((165, 15))
        self.text_ctrl_updated.SetMinSize((165, 27))
        self.label_10.SetMinSize((165, 15))
        self.button_force.SetMinSize((110, 27))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: MyFrame.__do_layout
        sizer_3 = wx.BoxSizer(wx.VERTICAL)
        sizer_17 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_18 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_4 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_6 = wx.BoxSizer(wx.VERTICAL)
        sizer_16 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_15 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_14 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_13 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_12 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_11 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_5 = wx.BoxSizer(wx.VERTICAL)
        sizer_10 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_9 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_8 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_7 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_19 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_19.Add((165, 20), 0, 0, 0)
        sizer_19.Add(self.label_1, 0, wx.RIGHT | wx.ALIGN_RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_7.Add(sizer_19, 1, wx.EXPAND, 2)
        sizer_7.Add(self.text_ctrl_status, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_3.Add(sizer_7, 0, wx.EXPAND, 2)
        sizer_3.Add(self.static_line_2, 0, wx.EXPAND, 2)
        sizer_8.Add(self.label_4, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_8.Add(self.text_ctrl_next, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_5.Add(sizer_8, 1, wx.EXPAND, 0)
        sizer_5.Add((330, 27), 0, 0, 0)
        sizer_9.Add(self.label_2, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_9.Add(self.text_ctrl_channel, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_5.Add(sizer_9, 1, wx.EXPAND, 0)
        sizer_10.Add(self.label_3, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_10.Add(self.text_ctrl_progress, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_5.Add(sizer_10, 1, wx.EXPAND, 0)
        sizer_5.Add((330, 27), 0, 0, 0)
        sizer_5.Add(self.gauge_progress, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_4.Add(sizer_5, 1, wx.ALL | wx.EXPAND, 2)
        sizer_4.Add(self.static_line_1, 0, wx.EXPAND, 0)
        sizer_11.Add(self.label_5, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_11.Add(self.text_ctrl_latest, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_6.Add(sizer_11, 1, wx.EXPAND, 0)
        sizer_12.Add(self.text_ctrl_seconds, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_12.Add(self.label_6, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_6.Add(sizer_12, 1, wx.EXPAND, 0)
        sizer_13.Add(self.text_ctrl_shows, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_13.Add(self.label_7, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_6.Add(sizer_13, 1, wx.EXPAND, 0)
        sizer_14.Add(self.text_ctrl_channels, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_14.Add(self.label_8, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_6.Add(sizer_14, 1, wx.EXPAND, 0)
        sizer_15.Add(self.text_ctrl_new, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_15.Add(self.label_9, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_6.Add(sizer_15, 1, wx.EXPAND, 0)
        sizer_16.Add(self.text_ctrl_updated, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_16.Add(self.label_10, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_6.Add(sizer_16, 1, wx.EXPAND, 0)
        sizer_4.Add(sizer_6, 1, wx.ALL | wx.EXPAND, 2)
        sizer_3.Add(sizer_4, 1, wx.ALL | wx.EXPAND, 2)
        sizer_3.Add(self.static_line_3, 0, wx.EXPAND, 2)
        sizer_18.Add((110, 20), 0, 0, 0)
        sizer_18.Add(self.button_force, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 2)
        sizer_18.Add((110, 20), 0, 0, 0)
        sizer_17.Add(sizer_18, 1, wx.EXPAND | wx.SHAPED, 2)
        sizer_17.Add((330, 20), 0, 0, 0)
        sizer_3.Add(sizer_17, 0, wx.EXPAND | wx.SHAPED, 2)
        self.SetSizer(sizer_3)
        self.Layout()
        # end wxGlade
            
    def OnClose(self, event):
        self.Timer.join()
        self.Destroy()
        
    def OnForce(self, event):
        self.button_force.Disable()
        self.Timer.startgrab()
        
    def updateDisplay(self, Params):
        #print Params.data
        ParamsList = DecodeParams(Params.data)
        self.DisplayStatus(ParamsList)
        self.DisplayNextGrab(ParamsList)
        self.DisplayProgress(ParamsList)           
        self.DisplayPrevInfo(ParamsList)
        self.Update()

    def DisplayStatus(self, ParamsList):
        Status = int(ParamsList[_STATUS])
        if (Status == STAT_UNKNOWN):
            self.text_ctrl_status.SetValue("Unknown")
        elif (Status == STAT_GRABBING):
            self.text_ctrl_status.SetValue("Grabbing")
            if self.button_force.IsEnabled() == True:
                self.button_force.Disable()
        elif (Status == STAT_IDLE):
            self.text_ctrl_status.SetValue("Idle")
            if self.button_force.IsEnabled() == False:
                self.button_force.Enable()
        elif (Status == STAT_ERROR):
            self.text_ctrl_status.SetValue("Error")
        elif (Status == STAT_POSTPROC):
            self.text_ctrl_status.SetValue("Post-processing")
        return

    def DisplayNextGrab(self, ParamsList):
        self.text_ctrl_next.SetValue(ParamsList[_NEXTGRAB])
        return

    def DisplayProgress(self, ParamsList):
        Status = int(ParamsList[_STATUS])
        Current = int(ParamsList[_CHANNELCOUNTER])
        Amount = int(ParamsList[_CHANNELS])
        if (Status == STAT_GRABBING):
            self.text_ctrl_channel.SetValue(ParamsList[_CHANNEL])
            self.text_ctrl_progress.SetValue("%d/ %d"%(Current, Amount))
        else:
            self.text_ctrl_channel.SetValue("None")
            self.text_ctrl_progress.SetValue("-")
        if (Amount == 0):
            self.gauge_progress.SetValue(0)
        else:
            self.gauge_progress.SetValue(Current*100/Amount)
        return        

    def DisplayPrevInfo(self, ParamsList):
        self.text_ctrl_latest.SetValue(ParamsList[_FINISHTIME])
        self.text_ctrl_seconds.SetValue(ParamsList[_DURATION])
        self.text_ctrl_shows.SetValue(ParamsList[_SHOWS])
        self.text_ctrl_channels.SetValue(ParamsList[_TOTALCHANNELS])
        self.text_ctrl_new.SetValue(ParamsList[_NEW])
        self.text_ctrl_updated.SetValue(ParamsList[_UPDATED])
        return

#####################################################            
# end of class MyFrame

if __name__ == "__main__":
    gettext.install("WebGrabGui") # replace with the appropriate catalog name

    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    
    if not getProcessPID('kodi.bin'):
        print "Kodi not running, WebGrabGui not possible"
        dlg = wx.MessageDialog(None, 
                "Kodi not running, WebGrabGui not possible",
                "Kodi error", wx.OK|wx.ICON_ERROR)
        result = dlg.ShowModal()
        dlg.Destroy()
        exit()
        
    #global url
    
    if len(sys.argv) > 1:
        url = "%s/jsonrpc"%sys.argv[1].lower()
    else:
        udf=GetUserDataFolder()
        guisetpath = os.path.join(udf,"guisettings.xml")
        port=GetPortFromKodi(guisetpath)
        url = 'http://127.0.0.1:%s/jsonrpc'%port
    
    path = json.loads(JsonRPC(url,JSONGETPATH))['result']['addon']['path']
    base,ext = os.path.split(path)
    basepath,ext2 = os.path.split(base)
    base = os.path.join(basepath,"userdata/addon_data")
    settingspath = os.path.join(os.path.join(base,ext),"settings.xml")
    
    #get settings
    GetSettingsFromKodi(settingspath)
    
    libpath = os.path.join(path,"resources/lib")
    sys.path.append(libpath)
    import progress

    frame_1 = MyFrame(None, wx.ID_ANY, "")
    app.SetTopWindow(frame_1)
    frame_1.Show()
    
    app.MainLoop()
